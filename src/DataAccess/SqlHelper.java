package DataAccess;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Hashtable;

import Util.JDBCUrlBuilder;

/**
 * A class used to encapsulate database access logic, to help keep the models as clean as possible.
 * @author nates
 *
 */
public class SqlHelper {
	
	private String _connection;
	private Connection _conn;
	public static String Username; //static, so this works for any instance of BaseDA
	public static String Pw; //static, so this works for any instance of BaseDA
	
	public SqlHelper() {
		String databaseName = ConfigurationReader.DATABASE_NAME;
		String databasePort = ConfigurationReader.DATABASE_PORT;
		String connectionUrl = ConfigurationReader.CONNECTION_URL;
		String databaseUsername = ConfigurationReader.DATABASE_USERNAME;
		String databasePassword = ConfigurationReader.DATABASE_PASSWORD;
		String[] fieldsToFetch = new String[5];
		
		fieldsToFetch[0] = databaseName;
		fieldsToFetch[1] = databasePort;
		fieldsToFetch[2] = databaseUsername;
		fieldsToFetch[3] = databasePassword;
		fieldsToFetch[4] = connectionUrl;
		
		Hashtable<String, String> configuration = new ConfigurationReader("config.xml").getConfiguration(fieldsToFetch);

		this._connection = JDBCUrlBuilder.build(
			configuration.get(connectionUrl),
			configuration.get(databasePort),
			configuration.get(databaseName),
			configuration.get(databaseUsername),
			configuration.get(databasePassword)
		);
	}
	/** 
	 * Generate a prepared statement for an insert.  Assumes the target table has a single SERIAL column, so the eventual execution of the provided statement will return the autogenerated integer.
	 * @param sql A sql string with the VALUES replaced with ?'s.  Parameters will be used to fill in the values of the insert.
	 * @return 
	 */
	public PreparedStatement GetPreparedInsertStatement(String sql)  {
		PreparedStatement stmt = null;

		try {
			Connection conn = GetConnection();
			stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return stmt;
	}
	
	public PreparedStatement GetPreparedInsertStatement(String sql, Boolean enableCommit)  {
		PreparedStatement stmt = null;

		try {
			Connection conn = GetConnection();
			conn.setAutoCommit(enableCommit);
			stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return stmt;
	}
	
	public PreparedStatement GetPreparedStatement(String sql)  {
		Connection conn;
		PreparedStatement stmt = null;

		try {
			conn = GetConnection();
			stmt = conn.prepareStatement(sql);
		} catch (Exception e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		return stmt;
	}
	
	public QueryResult ExecStatement(PreparedStatement stmt) {
		int rowCount;

		QueryResult result = new QueryResult();
		try {
			rowCount = stmt.executeUpdate();
			 if (rowCount == 0) {
				 result.ErrorMessage = "Record Delete/Update Failed, No data was changed.";
		     }
			 return result;
		} catch (SQLException e) {

			result.ErrorMessage = SimplifyError(e.getMessage());
			e.printStackTrace();
		}
		finally {
			try {
				if (stmt!=null) stmt.close();
				if (_conn!=null && !_conn.isClosed()) _conn.close();
				_conn = null;
			} catch (SQLException e) {
				e.printStackTrace();
			}
			System.out.println("Update / Delete Completed!");
		}
		return result;
	}
	
	public QueryResult ExecSql(String sql) {
		Connection conn;
		Statement stmt=null;
		try {
			conn = GetConnection();
			stmt = conn.createStatement();
		} catch (Exception e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		QueryResult result = new QueryResult();
		try {
			stmt.execute(sql);
		} catch (SQLException e) {

			result.ErrorMessage = SimplifyError(e.getMessage());
			e.printStackTrace();
		}
		finally {
			try {
				SqlHelper.CleanupResources(stmt, null);
			} catch (SQLException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		return result;
	}
	/**
	 * Executes an array of sql statements.
	 * 
	 * @return a queryresult
	 */
	public QueryResult ExecSql(String[] sql, Boolean commit) {
		Statement stmt=null;
		try {
			stmt = _conn.createStatement();
		} catch (Exception e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		QueryResult result = new QueryResult();
		try {
			for (String s : sql) {
				stmt.execute(s);
			}		
			if (commit) {_conn.commit();}
		} catch (SQLException e) {

			result.ErrorMessage = SimplifyError(e.getMessage());
			e.printStackTrace();
		}
		finally {
			try {
				SqlHelper.CleanupResources(stmt, null);
			} catch (SQLException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		return result;
	}
	
	/**
	 * Executes an insert statement, and if successful, returns the first auto generated key it finds.  Note that the caller must close stmt manually.
	 * 
	 * @return a queryresult
	 */
	public QueryResult ExecInsert(PreparedStatement stmt) {
		QueryResult result = new QueryResult();
		try {
			int rowCount = stmt.executeUpdate();

	        if (rowCount == 0) {
	            throw new SQLException("Record Create Failed, No data was created.");
	        }
	        try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
	            if (generatedKeys.next()) {
	            	result.Id = generatedKeys.getInt(1);
	                return (result);
	            }
	            else {
	                result.ErrorMessage = "Record Create Failed, could not obtain record id.";
	            }
	        }
		} catch (SQLException e) {
			result.ErrorMessage =SimplifyError(e.getMessage());
			e.printStackTrace();
		} finally {
			System.out.println("Insert Completed!");
		}
		return result;
	}
	
	private String SimplifyError(String errorMessage) {
		if (errorMessage.split("\n").length>1) {
			return errorMessage.split("\n")[0];
		}
		else {
			return errorMessage;
		}
	}
	public Connection GetConnection() throws Exception {
		if (_conn != null && !_conn.isClosed()) return _conn;

		try {
			_conn= DriverManager.getConnection(this._connection);
			System.out.println("Connection Established!");
			return _conn;
		}
		catch(Exception ex) {
			throw ex;
		}
	}

	public static void CleanupResources(Statement stmt, ResultSet rs) throws SQLException {
		if (rs!=null) rs.close();
		CleanupResources(stmt);
	}
	
	public static void CleanupResources(Statement stmt) throws SQLException {
		if (stmt!=null) {
			stmt.close();
			if (!stmt.getConnection().isClosed() && !stmt.getConnection().getAutoCommit()) stmt.getConnection().close(); //do not close a connection that was explicitly marked as "auto commit false".  Assume the caller will commit and close the connection manually in that case.
		}
	}
	
	public ConnectionInfo TestConnection() { 
		Connection conn = null;
		ConnectionInfo info = new ConnectionInfo();
		info.Connected = false;
		try {
			conn = this.GetConnection();
			info.Connected = true;
		} 
	catch (Exception ex) {
			info.Message = "Something unknown happened:\r\n "  + ex.getMessage(); 
			return info;
		} finally {
			if (conn != null) {
				try {
					conn.close();
				} catch (SQLException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		}
		return info;
	}
	
	public String get_connection() {
		return _connection;
	}

	public void set_connection(String _connection) {
		this._connection = _connection;
	}
}
